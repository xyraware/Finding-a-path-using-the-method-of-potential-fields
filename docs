Основные настройки чаще всего представлены в __main__, в создании экземпляра класса PotentialFieldRobot


!!!simple_movement.py!!!

Функции и их работа

1. __init__(width, height, start, goal, obstacles, k_att=1.0, k_rep=100.0, influence_radius=1.5, step_size=0.1, max_steps=1000)
   Инициализирует среду (ширина, высота), начальную точку ('start'), цель ('goal'), препятствия ('obstacles'), параметры: 'k_att' (сила притяжения), 'k_rep' (сила отталкивания), 'influence_radius' (радиус влияния препятствий), 'step_size' (шаг движения), 'max_steps' (максимум шагов).
   - Хранит текущую позицию ('current_pos') и путь ('path').

2. compute_attractive_force()
   - Вычисляет притягивающую силу: F_att = k_att * (goal - current_pos).
   - Тянет робота к цели пропорционально расстоянию.

3. compute_repulsive_force()
   - Вычисляет отталкивающую силу от препятствий в радиусе 'influence_radius'.
   - Формула: 'F_rep = k_rep * (1/dist - 1/influence_radius) * (1/dist^2) * (dist_vec/dist)'.
   - Суммирует силы от всех препятствий.

4. find_path_and_animate()
   - Выполняет поиск пути и визуализирует движение с помощью Matplotlib.
   - В цикле до 'max_steps':
     - Считает силы: 'f_att' (притяжение) + 'f_rep' (отталкивание) = 'f_total'.
     - Двигает робота на 'step_size' в направлении силы.
     - Обновляет путь и визуализацию.
     - Останавливается, если цель достигнута, робот застрял или превышен 'max_steps'.

Настраиваемые переменные

1. 'width', 'height': Размер среды (напр., 10x10).
2. ‘start’, ‘goal’: Координаты начальной точки и цели (напр., ‘(0, 0)’, ‘(9, 9)’).
3. ‘obstacles’: Список координат препятствий (напр., ‘[(2, 3), (3, 4)]’).
4. ‘k_att’: Сила притяжения (напр., 1.5 для сильного движения к цели).
5. ‘k_rep’: Сила отталкивания (напр., 120.0 для избегания препятствий).
6. ‘influence_radius’: Радиус влияния препятствий (напр., 2.0 для большего избегания).
7. ‘step_size’: Шаг движения (напр., 0.15 для плавности).
8. ‘max_steps’: Максимум шагов (напр., 1500 для длинных путей).

 Примечание
- Алгоритм обеспечивает простое движение: притяжение к цели и избегание препятствий.
- Настройте ‘k_att’, ‘k_rep’, ‘influence_radius’ для баланса между движением к цели и избеганием препятствий.
- Уменьшите ‘step_size’ для плавности, увеличьте ‘max_steps’ для больших сред.
- Располагайте препятствия так, чтобы избежать локальных минимумов.

 Пример настройки
- Среда: ‘WIDTH = 15’, ‘HEIGHT = 15’.
- Точки: ‘START_POS = (1, 1)’, ‘GOAL_POS = (14, 14)’.
- Препятствия: ‘OBSTACLES = [(5, 5), (7, 8)]’.
- Параметры: ‘k_att = 1.5’, ‘k_rep = 120.0’, ‘influence_radius = 2.0’, ‘step_size = 0.15’.



!!! force_normalization.py !!!
Функции и их работа

1. __init__(width, height, start, goal, obstacles, k_att=1.0, k_rep=100.0, influence_radius=1.5, step_size=0.1, max_steps=1000)
   Инициализирует среду (ширина, высота), начальную точку ('start'), цель ('goal'), препятствия ('obstacles'), параметры: 'k_att' (сила притяжения), 'k_rep' (сила отталкивания), 'influence_radius' (радиус влияния препятствий), 'step_size' (шаг движения), 'max_steps' (максимум шагов).
   - Хранит текущую позицию ('current_pos') и путь ('path').

2. compute_attractive_force()
   - Вычисляет притягивающую силу: F_att = k_att * (goal - current_pos).
   - Тянет робота к цели пропорционально расстоянию.

3. compute_repulsive_force()
   - Вычисляет отталкивающую силу от препятствий в радиусе 'influence_radius'.
   - Формула: 'F_rep = k_rep * (1/dist - 1/influence_radius) * (1/dist^2) * (dist_vec/dist)'.
   - Суммирует силы от всех препятствий.

3. smooth_force(force)
   - Сглаживает силу через скользящее среднее.
   - Хранит последние smooth_window сил в force_buffer, возвращает их среднее.

4. find_path_and_animate()
   -   поиск пути и визуализирует движение с помощью Matplotlib.
   - В цикле до 'max_steps':
     - Считает силы: 'f_att' (притяжение) + 'f_rep' (отталкивание) = 'f_total'.
     - Двигает робота на 'step_size' в направлении силы.
     - Обновляет путь и визуализацию.
     - Останавливается, если цель достигнута, робот застрял или превышен 'max_steps'.

Скользящее среднее в smooth_force сглаживает силы, предотвращая резкие изменения направления. Настройте smooth_window для баланса между плавностью и отзывчивостью.
В инициализации класса в конце программы настройте k_rep, influence_radius, smooth_window для оптимизации избегания препятствий и плавности.


!!! variable repulsion !!!
Функции и их работа
1) init(width, height, start, goal, obstacles, k_att=1.0, k_rep=100.0, influence_radius=1.5, step_size=0.1, max_steps=1000, k_rep_scale=10.0)
Инициализирует среду с заданной шириной (width) и высотой (height), начальной точкой (start), целевой точкой (goal) и списком препятствий (obstacles).
Параметры:
    - k_att: коэффициент силы притяжения к цели.
    - k_rep: коэффициент силы отталкивания от препятствий.
    - influence_radius: радиус влияния препятствий.
    - step_size: размер шага движения робота.
    - max_steps: максимальное количество шагов.
    - k_rep_scale: масштабирующий коэффициент для отталкивающей силы.
Хранит текущую позицию робота (current_pos) и путь (path) как список точек.

2) compute_attractive_force()
Вычисляет притягивающую силу к цели по формуле:F_att = k_att * (goal - current_pos).
Сила пропорциональна расстоянию до цели, направлена к ней.

3) compute_repulsive_force()
Рассчитывает отталкивающую силу от всех препятствий в радиусе influence_radius.
Формула для одного препятствия: F_rep = k_rep * (rho0 / dist)^k_rep_scale * (1/dist - 1/influence_radius) * (1/dist^2) * (dist_vec/dist).
Суммирует силы от всех препятствий, если расстояние до препятствия меньше influence_radius и больше 0.

4) find_path_and_animate()
Выполняет поиск пути и отображает анимацию движения с использованием библиотеки Matplotlib.
Алгоритм:
    - В цикле до max_steps:
    - Вычисляет суммарную силу: f_total = f_att + f_rep.
    - Перемещает робота на step_size в направлении силы.
    - Сохраняет текущую позицию в путь (path).
    - Обновляет визуализацию (график пути, начальной/конечной точки, препятствий, текущей позиции робота).
Остановка, если:
    -Достигнута цель (расстояние до цели < step_size).
    - Робот застрял (сила равна нулю).
    - Достигнуто максимальное количество шагов (max_steps).
Использует plt.ion() для интерактивной анимации и plt.pause() для обновления графика.
Настраиваемые переменные
    - width, height: Размеры среды (например, 10x10).
    - start, goal: Координаты начальной и целевой точек (например, (0, 0), (9, 9)).
    - obstacles: Список координат препятствий (например, [(2, 3), (3, 4), (4, 5)]).
    - k_att: Сила притяжения к цели (например, 1.0 для умеренного притяжения).
    - k_rep: Сила отталкивания от препятствий (например, 150.0 для сильного избегания).
    - influence_radius: Радиус действия препятствий (например, 2.0 для широкой зоны избегания).
    - step_size: Размер шага движения робота (например, 0.1 для плавного движения).
    - max_steps: Максимальное количество шагов (например, 1000 для больших сред).
    - k_rep_scale: Масштабирование отталкивающей силы (например, 10.0 для усиления эффекта).

Примечание
Уменьшайте step_size для большей точности, увеличивайте max_steps для сложных путей.
Избегайте плотного расположения препятствий, чтобы минимизировать локальные минимумы.

!!! dynamic_obstacles.py !!!

1. __init__(width, height, start, goal, obstacles, k_att=1.0, k_rep=100.0, influence_radius=1.5, step_size=0.1, max_steps=1000, k_rep_scale=2.0, obstacle_speed=0.0)
   - Инициализирует среду с заданной шириной (‘width’) и высотой (‘height’), начальной точкой (‘start’), целевой точкой (‘goal’) и списком препятствий (‘obstacles’).
   - Параметры:
     - ‘k_att’: коэффициент силы притяжения к цели.
     - ‘k_rep’: коэффициент силы отталкивания от препятствий.
     - ‘influence_radius’: радиус влияния препятствий.
     - ‘step_size’: размер шага движения робота.
     - ‘max_steps’: максимальное количество шагов.
     - ‘k_rep_scale’: масштабирующий коэффициент для отталкивающей силы.
     - ‘obstacle_speed’: скорость движения препятствий к роботу (0.0 для статичных препятствий).
   - Хранит текущую позицию робота (‘current_pos’) и путь (‘path’) как список точек.

2. compute_attractive_force()
   - Вычисляет притягивающую силу к цели по формуле:
     ‘F_att = k_att * (goal - current_pos)’.
   - Сила пропорциональна расстоянию до цели, направлена к ней.

3. compute_repulsive_force()
   - Рассчитывает отталкивающую силу от всех препятствий в радиусе ‘influence_radius’.
   - Формула для одного препятствия:
     ‘F_rep = k_rep * (rho0 / dist)^k_rep_scale * (1/dist - 1/influence_radius) * (1/dist^2) * (dist_vec/dist)’.
   - Суммирует силы от всех препятствий, если расстояние до препятствия меньше ‘influence_radius’ и больше 0.

4. update_obstacles()
   - Обновляет позиции препятствий, если ‘obstacle_speed’ > 0.
   - Каждое препятствие движется в направлении к текущей позиции робота с заданной скоростью (‘obstacle_speed’).
   - Формула движения: ‘obstacle_pos += obstacle_speed * (current_pos - obstacle_pos) / dist’.

5. find_path_and_animate()
   - Выполняет поиск пути и отображает анимацию движения с использованием библиотеки Matplotlib.
   - Алгоритм:
     - В цикле до ‘max_steps’:
       - Вычисляет суммарную силу: ‘f_total = f_att + f_rep’.
       - Перемещает робота на ‘step_size’ в направлении силы.
       - Сохраняет текущую позицию в путь (‘path’).
       - Если ‘obstacle_speed’ > 0, обновляет позиции препятствий с помощью ‘update_obstacles()’.
       - Обновляет визуализацию (график пути, начальной/конечной точки, препятствий, текущей позиции робота).
     - Остановка, если:
       - Достигнута цель (расстояние до цели < ‘step_size’).
       - Робот застрял (сила равна нулю).
       - Достигнуто максимальное количество шагов (‘max_steps’).
   - Использует ‘plt.ion()’ для интерактивной анимации и ‘plt.pause()’ для обновления графика.

 Настраиваемые переменные

1. ‘width’, ‘height’: Размеры среды (например, 10x10).
2. ‘start’, ‘goal’: Координаты начальной и целевой точек (например, ‘(0, 0)’, ‘(9, 9)’).
3. ‘obstacles’: Список координат препятствий (например, ‘[(2, 3), (3, 4), (4, 5)]’).
4. ‘k_att’: Сила притяжения к цели (например, 1.0 для умеренного притяжения).
5. ‘k_rep’: Сила отталкивания от препятствий (например, 150.0 для сильного избегания).
6. ‘influence_radius’: Радиус действия препятствий (например, 1.7 для средней зоны избегания).
7. ‘step_size’: Размер шага движения робота (например, 0.1 для плавного движения).
8. ‘max_steps’: Максимальное количество шагов (например, 1000 для больших сред).
9. ‘k_rep_scale’: Масштабирование отталкивающей силы (например, 2.0 для умеренного эффекта).
10. ‘obstacle_speed’: Скорость движения препятствий к роботу (например, 0.07 для медленного движения, 0.0 для статичных препятствий).

 Примечание
  - Уменьшайте ‘step_size’ для большей точности, увеличивайте ‘max_steps’ для сложных путей.
  - Настройте ‘obstacle_speed’ для контроля динамики препятствий (0.0 для статичных).
  - Избегайте плотного расположения препятствий, чтобы минимизировать локальные минимумы.



